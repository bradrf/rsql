#!/usr/bin/env ruby

# Copyright (C) 2011 by Brad Robel-Forrest <brad+rsql@gigglewax.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

begin
    # this isn't required unless that's how mysql and net/ssh have
    # been installed
    require 'rubygems'
rescue LoadError
end

require 'tmpdir'
require 'thread'
require 'timeout'
require 'readline'
require 'yaml'

# This is included below to make it optional if SSH is never needed.
# require 'net/ssh'

# allow ourselves to be run from within a source tree
if File.symlink?(__FILE__)
    fn = File.readlink(__FILE__)
else
    fn = __FILE__
end
libdir = File.expand_path(File.join(File.dirname(fn),'..','lib'))
$: << libdir if File.directory?(libdir)

require 'rsql'
include RSQL

bn = File.basename($0, '.rb')

eval_context = EvalContext.new

if i = ARGV.index('-rc')
    ARGV.delete_at(i)
    rc_fn = ARGV.delete_at(i)
else
    rc_fn = File.join(ENV['HOME'], ".#{bn}rc")
end

eval_context.load(rc_fn, false) if File.exists?(rc_fn)

def get_password(prompt)
    STDOUT.print(prompt)
    STDOUT.flush
    password = ''

    if RUBY_PLATFORM.match(/(win|w)32$/)
        require 'Win32API'
        begin
            wingetc = Win32API.new("msvcrt", "_getch", [ ], "L")
        rescue Exception
            wingetc = Win32API.new("crtdll", "_getch", [ ], "L")
        end
        while true do
            ch = wingetc.Call
            break if ch == ?\n || ch == ?\r
            password << ch
        end
    else
        begin
            `stty -echo`
            password = STDIN.gets
            password.chomp!
        ensure
            `stty echo`
            STDOUT.puts
        end
    end

    return password
end

# safely separate login credentials while preserving "emtpy" values--
# anything of the form [<username>[:<password]@]<host>[:<port>]
#
def split_login(str)
    login = []
    # search from the right so we don't pick out ampersands in a
    # password or username
    if i = str.rindex(?@)
        login << str[i+1..-1]
        if 0 < i
            str = str[0..i-1]
            i = str.index(?:)
            if 0 == i
                login << '' << str[i+1..-1]
            elsif i
                login << str[0..i-1] << str[i+1..-1]
            else
                login << str
            end
        else
            login << ''
        end
    else
        login << str
    end
    if login.first.sub!(/:(\d+)$/,'')
        login << $1.to_i
    else
        login << nil
    end
end

if ARGV.delete('-version')
    puts "#{bn} v#{RSQL::VERSION}"
    exit
end

verbose = ARGV.delete('-verbose')
eval_context.verbose = verbose

if i = ARGV.index('-maxrows')
    ARGV.delete_at(i)
    MySQLResults.max_rows = ARGV.delete_at(i).to_i
end

if i = ARGV.index('-batch')
    ARGV.delete_at(i)
    MySQLResults.field_separator = ARGV.delete_at(i)
    MySQLResults.field_separator = "\t" if MySQLResults.field_separator == '\t'
    batch_output = true
end

if i = ARGV.index('-ssh')
    require 'net/ssh'
    ARGV.delete_at(i)
    (ssh_host, ssh_user, ssh_password, ssh_port) = split_login(ARGV.delete_at(i))
end

if i = ARGV.index('-sshconfig')
    ARGV.delete_at(i)
    ssh_config = ARGV.delete_at(i)
end

if i = ARGV.index('-e')
    ARGV.delete_at(i)
    batch_input = ''
    ARGV.delete_if do |arg|
        arg_i = ARGV.index(arg)
        if i <= arg_i
            batch_input << ' ' << arg
        end
    end
    batch_input.strip!
end

if ARGV.size < 1
    prefix = '        ' << ' ' * bn.size
    $stderr.puts <<USAGE

usage: #{bn} [-version] [-help] [-verbose]
#{prefix}[-rc <rcfile>] [-maxrows <max>] [-batch <field_separator>]
#{prefix}[-ssh [<ssh_user>[:<ssh_password>]@]<ssh_host>[:<ssh_port>]
#{prefix}[-sshconfig <ssh_config>]
#{prefix}[<mysql_user>[:<mysql_password>]@]<mysql_host>[:<mysql_port>]
#{prefix}[<database>] [-e <remaining_args_as_input>]

  If -ssh is used, a SSH tunnel is established before trying to
  connect to the MySQL server.

  Commands may either be passed in non-interactively via the -e option
  or by piping into the process' standard input (stdin). If using -e,
  it _must_ be the last option following all other arguments.

USAGE
    exit 1
end

(mysql_host, mysql_user, mysql_password, mysql_port) = split_login(ARGV.shift)
mysql_password ||= get_password("#{mysql_user}@#{mysql_host} MySQL password: ")
real_mysql_host = mysql_host

if ssh_host
    # randomly pick a tcp port above 1024
    remote_mysql_port = mysql_port || 3306
    mysql_port = rand(0xffff-1025) + 1025
elsif mysql_port.nil?
    mysql_port = 3306
end

MySQLResults.database_name = ARGV.shift

unless $stdin.tty?
    batch_input = $stdin.read.gsub(/\r?\n/,';')
end

# make sure we remove any duplicates when we add to the history to
# keep it clean
#
def add_to_history(item)
    found = nil
    Readline::HISTORY.each_with_index do |h,i|
        if h == item
            found = i
            break
        end
    end
    Readline::HISTORY.delete_at(found) if found
    Readline::HISTORY.push(item)
end

# try closing but wrapped with a timer so we don't hang forever
#
def safe_timeout(conn, meth, name)
    Timeout.timeout(5) { conn.send(meth) }
    true
rescue Timeout::Error
    $stderr.puts "Timed out waiting to close #{name} connection"
    false
rescue Exception => ex
    $stderr.puts("#{ex.class}: #{ex.message}")
    false
end

MySQLResults.max_rows ||= batch_output ? 5000 : 1000

if ssh_host

    # might need to open an idle channel here so server doesn't close on
    # us...or just loop reconnection here in the thread...

    password_retry_cnt = 0

    unless batch_input
        print "SSH #{ssh_user}#{ssh_user ? '@' : ''}#{ssh_host}..."
        $stdout.flush
    end

    # we have to run mysql in a separate process due to the blocking
    # nature of its calls interfering with the pure ruby ssh
    # calls...so we'll run ssh in the background since its only
    # purpose is to forward us in for accessing the mysql server

    # we'll use a poor-man's ipc to determine when the ssh process is
    # ready
    ipc_fn = File.join(Dir.tmpdir, "rsql_ssh_#{$$}.pid")

    ssh = nil
    ssh_pid = Process.fork do
        File.open(ipc_fn,'w'){|f| f.puts('start')}
        ssh_enabled = false
        Signal.trap('INT') do
            $stderr.puts 'Shutting down...' unless batch_input
            ssh_enabled = false
        end
        opts = {:timeout => 15}
        opts[:config] = ssh_config if ssh_config
        if verbose
            opts[:verbose] = :debug
            puts "SSH options: #{opts.inspect}"
            if ssh_config
                puts "SSH config: #{Net::SSH::Config.load(ssh_config, ssh_host).inspect}"
            end
        end
        begin
            opts[:password] = ssh_password if ssh_password
            ssh = Net::SSH.start(ssh_host, ssh_user, opts)
            ssh_enabled = true
            printf "connected (#{$$})..." unless batch_input
            $stdout.flush
        rescue Net::SSH::AuthenticationFailed
            if 2 < password_retry_cnt
                $stderr.puts 'Permission denied. Giving up.'
            else
                $stderr.puts 'Permission denied, please try again.' if ssh_password
                ssh_password = get_password("#{ssh_user}@#{ssh_host} SSH password: ")
                unless ssh_password.empty?
                    password_retry_cnt += 1
                    retry
                end
            end
        end
        if ssh_enabled
            ssh.forward.local(mysql_port, mysql_host, remote_mysql_port)
            unless batch_input
                puts(verbose ? "ready (#{mysql_port} => #{remote_mysql_port})" : 'ready')
            end
            File.open(ipc_fn,'w'){|f| f.puts('ready')}
            ssh.loop(1) { ssh_enabled }
        end
        File.open(ipc_fn,'w'){|f| f.puts('fail')}
    end

    ipc_state = ''
    60.times do
        sleep(1)
        File.open(ipc_fn,'r'){|f| ipc_state = f.gets.strip}
        break if ipc_state == 'ready' || ipc_state == 'fail'
    end

    File.unlink(ipc_fn)

    unless ipc_state == 'ready'
        $stderr.puts "failed to connect to #{ssh_host} SSH host"
        exit 1
    end

    # now have our mysql connection use our port forward...
    mysql_host = '127.0.0.1'
end

unless batch_input
    print "MySQL #{mysql_user}@#{real_mysql_host}..."
    $stdout.flush
end

mysql_conn = "#{mysql_host}:#{remote_mysql_port || mysql_port}"

begin
    MySQLResults.conn = Mysql.new(mysql_host, mysql_user, mysql_password,
                                  MySQLResults.database_name, mysql_port)
    puts 'connected' unless batch_input
rescue Mysql::Error => ex
    if ex.message.include?('Client does not support authentication')
        $stderr.puts "failed to connect to #{mysql_conn} mysql server: unknown credentials?"
    else
        $stderr.puts "failed to connect to #{mysql_conn} mysql server: #{ex.message}"
    end
    $stderr.puts ex.backtrace if verbose
    exit 1
rescue NoMethodError
    # this happens when mysql tries to read four bytes and assume it
    # can index into them even when read returned nil...this happens
    # because the connect succeeds due to the SSH forwarded port but
    # then there isn't anybody connected on the remote side of the
    # proxy
    $stderr.puts "failed to connect to #{mysql_conn} mysql server"
    $stderr.puts ex.backtrace if verbose
    exit 1
rescue Exception => ex
    $stderr.puts "failed to connect to #{mysql_conn} mysql server: #{ex.message} (#{ex.class})"
    $stderr.puts ex.backtrace if verbose
    exit 1
end

eval_context.call_init_registrations

history_fn = File.join(ENV['HOME'], ".#{bn}_history")
if File.exists?(history_fn) && 0 < File.size(history_fn)
    YAML.load_file(history_fn).each {|i| Readline::HISTORY.push(i)}
end

Readline.completion_proc = eval_context.method(:complete)

cmd_thread = Thread.new do
    me = Thread.current
    me[:shutdown] = false
    until me[:shutdown] do
        default_displayer = :display_by_column
        if batch_input
            default_displayer = :display_by_batch if batch_output
            me[:shutdown] = true         # only run once
            input = batch_input
        else
            puts '',"[#{mysql_user}@#{ssh_host||mysql_host}:#{MySQLResults.database_name}]"
            input = ''
            prompt = bn + '> '
            loop do
                str = Readline.readline(prompt)
                if str.nil?
                    input = nil if input.empty?
                    break
                end
                if str =~ /^\s*(exit|quit)\s*$/
                    me[:shutdown] = true
                    break
                end
                input << str
                break if input =~ /([^\\];|\\G)\s*$/ || input =~ /^\s*use\s+\w+\s*$/
                # make sure we separate the lines with some whitespace if
                # they didn't
                input << ' ' unless str =~ /\s$/
                prompt = ''
            end
            if input.nil? || me[:shutdown]
                puts
                break
            end
            input.strip!
            next if input.empty?
        end

        add_to_history(input)
        cmds = Commands.new(input, default_displayer)
        if cmds.empty?
            Readline::HISTORY.pop
            next
        end

        me[:running] = true
        break if cmds.run!(eval_context) == :done
        me[:running] = false
    end
end

Signal.trap('INT') do
    if cmd_thread[:running] && MySQLResults.conn
        $stderr.puts 'Interrupting MySQL query...'
        safe_timeout(MySQLResults.conn, :close, 'MySQL')
        MySQLResults.conn = nil
    end
    $stderr.puts 'Shutting down...'
    cmd_thread[:shutdown] = true
    sleep(0.3)
    cmd_thread.kill
end

Signal.trap('CHLD') do
    $stderr.puts "SSH child (#{ssh_pid}) stopped--shutting down..."
    if cmd_thread[:running] && MySQLResults.conn
        $stderr.puts 'Interrupting MySQL query...'
        safe_timeout(MySQLResults.conn, :close, 'MySQL')
        MySQLResults.conn = nil
    end
    cmd_thread[:shutdown] = true
    sleep(0.3)
    cmd_thread.kill
end

begin
    cmd_thread.join
rescue Exception => ex
    $stderr.puts ex.message, ex.backtrace
end

unless MySQLResults.conn.nil?
    safe_timeout(MySQLResults.conn, :close, 'MySQL')
    MySQLResults.conn = nil
end

sleep(0.3)

if Readline::HISTORY.any?
    if 100 < Readline::HISTORY.size
        (Readline::HISTORY.size - 100).times do |i|
            Readline::HISTORY.delete_at(i)
        end
    end
    File.open(history_fn, 'w') {|f| YAML.dump(Readline::HISTORY.to_a, f)}
end

if ssh_pid && 0 <= ssh_pid
    begin
        Process.kill('INT', ssh_pid)
        Process.waitpid(ssh_pid)
    rescue Exception => ex
        $stderr.puts ex.message
        $stderr.puts ex.backtrace if verbose
    end
end
